Part 2 creates an initial child process Q of the parent process P. This child then
executes through the first conditional block, stores the sum of a and b in a, then prints it's PID and
the values a and b. 

Q then forks itself into a new child process R. Because of the fork process, in Q
'fr' stores the parent's PID (which is Q's PID), and so maybe enter the next
conditional block, adding 20 to b and storing the result in b, then printing the
information. Meanwhile, R's copy of 'fr' stores '0' returned from the fork process
and so it cannot execute the if condition, instead it executes the else statement
multiplying a and b and adding 30. It displays the variables a,b, and it's PID. Both
copies continue to run and return 0.

Meanwhile, parent process P, continues to run from the point at which Q was forked.
Like the above case, fq stores the PID of the parent P, so it can't execute the if
condition, jumping to the else condition, which adds a,b and then subtracts 5. It
then exits with a return 0.

There are no waitpid(), so I found the execution order to be P,Q,R in both Debian
and Ubuntu operating environments. 
